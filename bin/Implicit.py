#!/usr/bin/env python

import sys
import getopt
import string
import copy
from   Tools.functions     import bIsIntrinsic
from   Tools.Project       import Project
from   Tools.ModifyFile    import ModifyFile
from   AOR.Declaration     import Implicit, Use, Declaration
from   AOR.ProgUnit        import IncompleteProgUnit
from   AOR.AttributeString import CommentLine

# ==============================================================================
# Creates implicit none. Currently, the following approach must be used:
# 1) Handling all include files (since otherwise the variables would be
#    declared in the .F files, and not in the include files).
#    Problem: what happens if a variable is in a common block in a.inc,
#             but actually declared in b.h, which is NOT included in a.inc
#             (Yes, I've seen that). In this case the variable will be declared
#             in a.inc, which will give a duplicated declaration error later)
# 2) Then handling all Fortran source files
#
# Note: a better version could be implemented by keeping track of which
#       variables are declared in what include files (which I think is already
#       partly done) and the declare undeclared variables in the corresponding
#       .h files. This would solve the issue mentioned above.

class ImplicitNonify:
    def __init__(self, oFile):
        if not oFile:
            # Can happen in case of parsing errors, or for empty include files
            # which only contain #include and comments.
            return
        self.modify  = ModifyFile(oFile.sGetFilename())
        bWasModified = 0
        for progUnit in oFile:
            self.dDecl   = {}
            bWasModified = self.bDoProgUnit(oFile, progUnit) or bWasModified
            for i in progUnit.lContainedProgUnits():
                self.dDecl   = {}
                bWasModified = self.bDoProgUnit(oFile, i) or bWasModified
                
        if bWasModified:
            self.modify.WriteBack(oFile.sGetFilename()+".none")
    # --------------------------------------------------------------------------
    def AddDeclaration(self, var):
        sType = `var["type"]`
        decl = self.dDecl.get(sType, None)
        if not decl:
            decl = Declaration(sType=var["type"])
            self.dDecl[sType] = decl
        decl.AppendVariable(var)
        
    # --------------------------------------------------------------------------
    # Writes the start comment
    def WriteHeader(self, oFile, statement):
        self.modify.AddLine(oFile.sFormatObject(
            CommentLine("!------------------------------------------------------+")),
                            statement)
        self.modify.AddLine(oFile.sFormatObject(
            CommentLine("! Implicit none automatically generated by STAN, NEC/A |")),
                            statement)
        self.modify.AddLine(oFile.sFormatObject(
            CommentLine("!------------------------------------------------------+")),
                            statement)
        
    # --------------------------------------------------------------------------
    # If the program unit is not implicit none, an implicit none statement
    # and the missing declarations will be created.
    # Return value: 1 if the file was modified, 0 otherwise
    def bDoProgUnit(self, oFile, progUnit):

        # First check for existing implicit statements
        # Remove them if it's not an implicit none,
        # otherwise stop, since implicit none does not
        # allow any other implicit statements!
        # --------------------------------------------
        lImplicit = []
        for statement in progUnit:
            if statement.isA(Implicit):
                if statement.isNone():
                    print "%s is already implicit none"%progUnit.sGetName()
                    return 0
                self.modify.RemoveStatement(statement)

        # Find the proper location to add an implicit none,
        # which is after the last 'use' statement
        # -------------------------------------------------

        # Only add implicit none if it is not an incomplete program unit
        # Otherwise it's an include file which shouldn't contain any
        # implicit statements, but it must contain the declarations.
        if not isinstance(progUnit, IncompleteProgUnit):
            for statement in progUnit[1:]:  # Ignore the subroutine/.. statement
                if not statement.isA(Use): break
            implNone = Implicit()
            implNone.SetImplicitNone()
            self.WriteHeader(oFile, statement)
            self.modify.AddLine(`implNone`,statement)
            bModified = 2
        else:
            bModified = 0
            for statement in progUnit:
                if not statement.isA(Use): break
        d={}
        for v in progUnit.lGetAllVariables():
            if v['undefined'] and not bIsIntrinsic(`v`):
                self.AddDeclaration(v)
                if not bModified:
                    bModified = 1
                
        for (sName, loc) in progUnit.lGetFunctionCalls():
            sFuncName = progUnit.GetVariable(sName, bAutoAdd=0)
            if not sFuncName and not bIsIntrinsic(sName):
                sFuncName = progUnit.GetVariable(sName)
                self.AddDeclaration(sFuncName)
                
                
        if bModified==1: self.WriteHeader(oFile, statement)

        for decl in self.dDecl.values():
            self.modify.AddLine(oFile.sFormatObject(decl, bIgnoreAttributes=1),
                                statement)
        if bModified:
            self.modify.AddLine(oFile.sFormatObject(
                CommentLine("!------------------------------------------------------+")),
                                statement)
            self.modify.AddLine(oFile.sFormatObject(
                CommentLine("! End of code generated by STAN, NEC/A                 |")),
                                statement)
            self.modify.AddLine(oFile.sFormatObject(
                CommentLine("!------------------------------------------------------+")),
                                statement)

        return 1
# ==============================================================================
def Usage():
    print """Implicit file1 file2 ...
For each file specified a new file (with a 'none' inserted before the suffix)
in which an "implicit none" is inserted and all undeclared variables of the
original file are declared.
"""
    sys.exit(-1)
# ==============================================================================

if __name__=="__main__":
    if len(sys.argv)<=1:
        Usage()
    bProfile = 0
    if not bProfile:
        project = Project()
        for i in sys.argv[1:]:
            print "Implicit-none-ifying",i
            obj = project.oGetObjectForIdentifier(i, "file")
            ImplicitNonify(obj)
        sys.exit()

    if bProfile:
        import profile
        profile.run(
"""
project = Project()
for i in sys.argv[1:]:
    print 'Implicit-none-ifying',i
    obj = project.oGetObjectForIdentifier(i, "file")
    ImplicitNonify(obj)
""")
        sys.exit()
